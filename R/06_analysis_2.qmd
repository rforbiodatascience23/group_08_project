---
title: "06_analysis_2"
format: html
editor: visual
---

## Loading libraries

```{r}
#| message: false
library(tidyverse)
library(DiscoNet) # install_github("gmoranzoni/DiscoNet")
library(msigdbr)
library(fgsea)
library(ggraph)
library(igraph)
source("99_proj_func.R")
```

```{r}
# string_database <- translate_database("string") # save on the first iteration since it takes somtime to run
# save(string_database, file = "../data/string_database.RData")

load("../data/GSE182951_diff_nonpCR_pre_post_genes.RData")
load("../data/GSE182951_diff_pCR_pre_post_genes.RData")
load("../data/string_database.RData")

```

```{r}
View(GSE182951_diff_pCR_pre_post_genes)
View(GSE182951_diff_nonpCR_pre_post_genes)
View(string_database)

```

## **Virtual Pull-down**

### Virtual Pull-down

Here we are performing a virtual pull down which is a method of detecting protein-protein interactions of the genes of interest by fetching interactions from the STRING database loaded above, it then identifies all the interactions for the provided seed nodes, found in analysis 1, these are all the genes with log2fold changes above 1 or below -1 when comparing pre and post treatment in the pCR and non-pCR groups.

```{r}
network_pCR <- virtual_pulldown(
  seed_nodes = GSE182951_diff_pCR_pre_post_genes, 
  database = string_database, 
  id_type = "hgnc", # HUGO Gene Nomenclature Comittee
  string_confidence_score = 700) # default value
```

```{r}
network_nonpCR <- virtual_pulldown(
  seed_nodes = GSE182951_diff_nonpCR_pre_post_genes, 
  database = string_database, 
  id_type = "hgnc", # HUGO Gene Nomenclature Comittee
  string_confidence_score = 700 ) # default value

```

The following step creates two sub-data frames for each of the pull downs, with the interaction of all the proteins identified and their attributes which includes a calculated relevance score for the interactions found. Here we are using \$ instead of **select** because the output of the virtual_pull-down function is a list object.

```{r}
interactions_pCR <- network_pCR$network |> 
  as.data.frame()

# could also be solved like this "network_pCR[["network"]]"

node_attributes_pCR <- network_pCR$node_attributes |> 
  as.data.frame() 
```

```{r}
interactions_nonpCR <- network_nonpCR$network |> 
  as.data.frame()

node_attributes_nonpCR <-  network_nonpCR$node_attributes |> 
  as.data.frame() 

```

The following step constructs igraph objects, graphs, from the interactions and n odes for all the nodes in the pull downs.

```{r}
graph_pCR <- graph_from_data_frame(
  interactions_pCR, 
  directed = FALSE,
  vertices = node_attributes_pCR)

# these three steps are to filter the interactions with a relevance score of 0.8 or lower; and unconnected nodes, that is nodes with degree 0. 
# We tried doing it with tidy R but the pipes and mutate function did not work properly because they are igraph objects, not data frames or tibbles, and when we tried to read as data frame it was not possible to run the igraph functions of them. Same below. 

graph_pCR_1 <- relevance_filtering(graph_pCR, 0.8)
isolated_nodes <- which(degree(graph_pCR_1) == 0)
graph_pCR_1 <- delete_vertices(graph_pCR_1, 
                               isolated_nodes)

```

```{r}
graph_nonpCR <- graph_from_data_frame(
  interactions_nonpCR, 
  directed = FALSE,
  vertices = node_attributes_nonpCR)

graph_nonpCR_1 <- relevance_filtering(graph_nonpCR, 0.8)
isolated_nodes <- which(degree(graph_nonpCR_1) == 0)
graph_nonpCR_1 <- delete_vertices(graph_nonpCR_1, 
                                  isolated_nodes)

```

### Communities

This step isused to detect communities, and therefore potential protein complexes that might be identified form the interactions found among all the genes above. Specifically we use the mcode algorithm, which is a clustering algorithm used to identify molecular complexes in protein interactions networks through a three-stage process:

1.  **Weighting**: giving a higher score to the nodes with neighboring nodes that are are more interconnected
2.  **Molecular complex prediction**: starts with the node with highest-weight and it moves out recursively, adding nodes to the complex that are above a given threshold, in this case D.
3.  **Post-processing**: it applies filters to improve the cluster quality (haircut)

```{r}
communities_nonpCR <- community_detection(
  graph_nonpCR_1, 
  algorithm = "mcode", 
  D = 0.05, # default vertex weight percentage for mcode
  haircut = TRUE) # trims singly-connected nodes, nodes that are unlilkely to have real function in the complex 


communities_pCR <- community_detection(
  graph_pCR_1, 
  algorithm = "mcode", 
  D = 0.05, 
  haircut = TRUE)

```

### Graphing Communities with create_and_save_graph function

```{r}
# Subitems for communities_nonpCR
nonpCR_subcommunities <- c(1, 2, 11, 23, 80)

# Subitems for communities_pCR
pCR_subcommunities <- c(1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13)


for (i in nonpCR_subcommunities) {
  create_and_save_graph(communities_nonpCR, GSE182951_diff_nonpCR_pre_post_genes, "nonpCR", i, output_dir = "../results/")
}

# Loop through communities_pCR and create/save graphs
for (i in pCR_subcommunities) {
  create_and_save_graph(communities_pCR, GSE182951_diff_pCR_pre_post_genes,"pCR", i, output_dir = "../results/")
}

```

## Gene Enrichment Analysis

### Preparing data

For gene enrichment analysis, there are two methods over representation analysis, and functional class scoring. Here we will be performing the first of the two and for that we need two inputs:

1.  target gene list of interest, (obtained in the previous analysis)
2.  background gene list
3.  the gene sets to be examined over representation.

```{r}

biological_process_df = msigdbr(species = "human", category = "C5", subcategory = "BP")

BP_list = split(x = biological_process_df$gene_symbol, f = biological_process_df$gs_name)

biological_process_list <- biological_process_df |> 
  select(gene_symbol, gs_name)  |> 
  group_by(gs_name)  |> 
  summarise(gene_symbols = list(gene_symbol))  |> 
  ungroup()


BP_list_2 <- biological_process_df |> 
  select(gene_symbol, gs_name) |> 
  group_by(gs_name) |> 
  summarize(gene_symbols = list(unique(gene_symbol))) |> 
  ungroup() |> 
  pull(gene_symbols)



```

### Over representation analysis

```{r}
# Subitems for communities_nonpCR
nonpCR_subcommunities <- c(1, 2, 11, 23, 80)

# Subitems for communities_pCR
pCR_subcommunities <- c(1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13)


for (i in pCR_subccommunities) {ora_results_pCR <- fora(
  pathways = BP_list, 
  genes = V(communities_pCR$communities[[i]])$name, 
  universe = GSE182951_diff_nonpCR_pre_post_genes, 
  minSize = 10)

}

for (i in nonpCR_subccommunities) {ora_results_nonpCR <- fora(
  pathways = BP_list, 
  genes = V(communities_nonpCR$communities[[i]])$name, 
  universe = GSE182951_diff_pCR_pre_post_genes, 
  minSize = 10)

}

```

```{r}
# Subitems for communities_nonpCR
nonpCR_subcommunities <- c(1, 2, 11, 23, 80)

# Subitems for communities_pCR
pCR_subcommunities <- c(1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13)

# Create lists to store results
ora_results_nonpCR <- list()
ora_results_pCR <- list()

# Loop for communities_pCR
for (i in pCR_subcommunities) {
  ora_results_pCR[[i]] <- fora(
    pathways = BP_list, 
    genes = V(communities_pCR$communities[[i]])$name, 
    universe = GSE182951_diff_nonpCR_pre_post_genes, 
    minSize = 10
  )
}

# Loop for communities_nonpCR
for (i in nonpCR_subcommunities) {
  ora_results_nonpCR[[i]] <- fora(
    pathways = BP_list, 
    genes = V(communities_nonpCR$communities[[i]])$name, 
    universe = GSE182951_diff_pCR_pre_post_genes, 
    minSize = 10
  )
}
```

Next step is to make the lists tidy
